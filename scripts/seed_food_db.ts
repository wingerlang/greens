
import { parse } from "https://deno.land/std@0.224.0/csv/parse.ts";

// Redefine FoodCategory locally to ensure script independence while matching src/models/types.ts
type FoodCategory =
    | 'vegetables'
    | 'fruits'
    | 'grains'
    | 'legumes'
    | 'protein'
    | 'fats'
    | 'beverages'
    | 'dairy-alt'
    | 'nuts-seeds'
    | 'spices'
    | 'condiments'
    | 'sauces'
    | 'sweeteners'
    | 'baking'
    | 'supplements'
    | 'other';

const INPUT_FILE = "./data/LivsmedelsDB_Cleaned_Vegan.csv";
const OUTPUT_FILE = "./src/data/generatedFoodData.ts";

async function main() {
    console.log("Reading CSV...");
    try {
        const csvContent = await Deno.readTextFile(INPUT_FILE);

        const records = parse(csvContent, {
            skipFirstRow: true,
            columns: [
                "Name", "Category", "Calories", "Protein", "Fat", "Carbs", "Fiber",
                "Sugar", "AddedSugar", "WholeGrains", "SaturatedFat", "MonounsaturatedFat",
                "PolyunsaturatedFat", "Cholesterol", "VitaminD", "VitaminB12", "Iron",
                "Zinc", "Calcium", "Omega3", "Omega6", "IsVegan"
            ],
        });

        console.log(`Found ${records.length} records.`);

        const foodItems = [];

        for (const record of records) {
            // Map Category
            const cat = mapCategory(record.Category as string);

            const item = {
                id: `gen_${crypto.randomUUID().split('-')[0]}`, // Short unique ID prefixed
                name: (record.Name as string).trim(),
                calories: parseFloat(record.Calories as string) || 0,
                protein: parseFloat(record.Protein as string) || 0,
                carbs: parseFloat(record.Carbs as string) || 0,
                fat: parseFloat(record.Fat as string) || 0,
                fiber: parseFloat(record.Fiber as string) || 0,

                unit: 'g', // Default per 100g
                category: cat,

                // Core Micros
                iron: parseFloat(record.Iron as string) || 0,
                zinc: parseFloat(record.Zinc as string) || 0,
                calcium: parseFloat(record.Calcium as string) || 0,
                vitaminB12: parseFloat(record.VitaminB12 as string) || 0,
                // VitaminD is in Extended

                extendedDetails: {
                    sugar: parseFloat(record.Sugar as string) || 0,
                    addedSugar: parseFloat(record.AddedSugar as string) || 0,
                    wholeGrains: parseFloat(record.WholeGrains as string) || 0,
                    saturatedFat: parseFloat(record.SaturatedFat as string) || 0,
                    monounsaturatedFat: parseFloat(record.MonounsaturatedFat as string) || 0,
                    polyunsaturatedFat: parseFloat(record.PolyunsaturatedFat as string) || 0,
                    cholesterol: parseFloat(record.Cholesterol as string) || 0,
                    vitaminD: parseFloat(record.VitaminD as string) || 0,
                    omega3: parseFloat(record.Omega3 as string) || 0,
                    omega6: parseFloat(record.Omega6 as string) || 0,
                },

                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            foodItems.push(item);
        }

        // Generate TS File Content
        // We rely on TypeScript's structural typing. The exported array is typed as FoodItem[],
        // so the string literals in the JSON will be validated against the Unit and FoodCategory types.
        const fileContent = `// deno-lint-ignore-file
// Auto-generated by scripts/seed_food_db.ts
import { FoodItem } from '../models/types.ts';

export const GENERATED_FOOD_ITEMS: FoodItem[] = ${JSON.stringify(foodItems, null, 4)};
`;

        await Deno.writeTextFile(OUTPUT_FILE, fileContent);
        console.log(`Wrote ${foodItems.length} items to ${OUTPUT_FILE}`);

    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            console.error(`Error: Input file not found at ${INPUT_FILE}`);
        } else {
            console.error("An unexpected error occurred:", error);
        }
        Deno.exit(1);
    }
}

function mapCategory(sweCat: string): FoodCategory {
    const c = sweCat.toLowerCase();

    // Explicit mapping refinements (Higher priority)
    if (c.includes('sås')) return 'sauces';
    if (c.includes('bak')) return 'baking';

    // General mappings
    if (c.includes('frukt') || c.includes('bär')) return 'fruits';
    if (c.includes('grönsak') || c.includes('rotfrukt')) return 'vegetables';
    if (c.includes('bröd') || c.includes('mjöl') || c.includes('gryn') || c.includes('pasta') || c.includes('ris')) return 'grains';
    if (c.includes('bönor') || c.includes('linser') || c.includes('ärter')) return 'legumes';
    if (c.includes('kött') || c.includes('korv') || c.includes('soja') || c.includes('tofu')) return 'protein';
    if (c.includes('nöt') || c.includes('frö')) return 'nuts-seeds';
    if (c.includes('olja') || c.includes('fett')) return 'fats';
    if (c.includes('dryck')) return 'beverages';
    if (c.includes('krydda')) return 'condiments';
    if (c.includes('sötsak') || c.includes('godis') || c.includes('socker')) return 'sweeteners';
    if (c.includes('mejeri') || c.includes('ost') || c.includes('grädde')) return 'dairy-alt';

    // Default fallback
    return 'other';
}

if (import.meta.main) {
    main();
}
