
import { parse } from "https://deno.land/std@0.224.0/csv/parse.ts";

// Define simplified interfaces to avoid importing complex types from src if not needed for generation script
// or just use string construction.

const INPUT_FILE = "./LivsmedelsDB_Cleaned_Vegan.csv";
const OUTPUT_FILE = "./src/data/generatedFoodData.ts";

async function main() {
    console.log("Reading CSV...");
    const csvContent = await Deno.readTextFile(INPUT_FILE);

    const records = parse(csvContent, {
        skipFirstRow: true,
        columns: [
            "Name", "Category", "Calories", "Protein", "Fat", "Carbs", "Fiber",
            "Sugar", "AddedSugar", "WholeGrains", "SaturatedFat", "MonounsaturatedFat",
            "PolyunsaturatedFat", "Cholesterol", "VitaminD", "VitaminB12", "Iron",
            "Zinc", "Calcium", "Omega3", "Omega6", "IsVegan"
        ],
    });

    console.log(`Found ${records.length} records.`);

    const foodItems = [];

    for (const record of records) {
        // Map Category
        const cat = mapCategory(record.Category as string);

        // Skip if category is obviously not food we support (can filter more here)

        const item = {
            id: `gen_${crypto.randomUUID().split('-')[0]}`, // Short unique ID prefixed
            name: (record.Name as string).trim(),
            calories: parseFloat(record.Calories as string) || 0,
            protein: parseFloat(record.Protein as string) || 0,
            carbs: parseFloat(record.Carbs as string) || 0,
            fat: parseFloat(record.Fat as string) || 0,
            fiber: parseFloat(record.Fiber as string) || 0,

            unit: 'g', // Default per 100g
            category: cat,

            // Core Micros
            iron: parseFloat(record.Iron as string) || 0,
            zinc: parseFloat(record.Zinc as string) || 0,
            calcium: parseFloat(record.Calcium as string) || 0,
            vitaminB12: parseFloat(record.VitaminB12 as string) || 0,
            // VitaminD is in Extended

            extendedDetails: {
                sugar: parseFloat(record.Sugar as string) || 0,
                addedSugar: parseFloat(record.AddedSugar as string) || 0,
                wholeGrains: parseFloat(record.WholeGrains as string) || 0,
                saturatedFat: parseFloat(record.SaturatedFat as string) || 0,
                monounsaturatedFat: parseFloat(record.MonounsaturatedFat as string) || 0,
                polyunsaturatedFat: parseFloat(record.PolyunsaturatedFat as string) || 0,
                cholesterol: parseFloat(record.Cholesterol as string) || 0,
                vitaminD: parseFloat(record.VitaminD as string) || 0,
                omega3: parseFloat(record.Omega3 as string) || 0,
                omega6: parseFloat(record.Omega6 as string) || 0,
            },

            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        foodItems.push(item);
    }

    // Generate TS File Content
    const fileContent = `// Auto-generated by scripts/seed_food_db.ts
import { FoodItem } from '../models/types.ts';

export const GENERATED_FOOD_ITEMS: FoodItem[] = ${JSON.stringify(foodItems, null, 4).replace(/"unit": "g"/g, '"unit": "g" as const').replace(/"category": "([a-z-]+)"/g, '"category": "$1" as any')};
`;

    // The regex above is a bit hacky to fix types, but let's trust the JSON for now. 
    // We need to cast "category" to FoodCategory, or import it.
    // Better: Type assertion in the mapped object logic? No, JSON.stringify kills it.
    // I made a hacky replace. Ideally I shouldn't rely on replaces. 
    // Let's rely on type inference or `as const` if possible, but JSON is strict.

    // Cleaner: 
    // export const GENERATED_FOOD_ITEMS: FoodItem[] = [...json array...];
    // TypeScript will complain if strings don't match enum.

    await Deno.writeTextFile(OUTPUT_FILE, fileContent);
    console.log(`Wrote ${foodItems.length} items to ${OUTPUT_FILE}`);
}

function mapCategory(sweCat: string): string {
    const c = sweCat.toLowerCase();
    if (c.includes('frukt') || c.includes('bär')) return 'fruits';
    if (c.includes('grönsak') || c.includes('rotfrukt')) return 'vegetables';
    if (c.includes('bröd') || c.includes('mjöl') || c.includes('gryn') || c.includes('pasta') || c.includes('ris')) return 'grains';
    if (c.includes('bönor') || c.includes('linser') || c.includes('ärter')) return 'legumes';
    if (c.includes('kött') || c.includes('korv') || c.includes('soja') || c.includes('tofu')) return 'protein';
    // Note: CSV is filtered vegan, so 'kött' might be 'vegokött' etc.
    if (c.includes('nöt') || c.includes('frö')) return 'nuts-seeds';
    if (c.includes('olja') || c.includes('fett')) return 'fats';
    if (c.includes('dryck')) return 'beverages';
    if (c.includes('krydda') || c.includes('sås')) return 'condiments';
    if (c.includes('sötsak') || c.includes('godis') || c.includes('socker')) return 'sweeteners';
    if (c.includes('mejeri') || c.includes('ost') || c.includes('grädde')) return 'dairy-alt';

    return 'other';
}

main();
